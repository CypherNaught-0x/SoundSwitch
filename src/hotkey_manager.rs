use crate::config::{Config, HotkeyMapping};
use global_hotkey::{
    GlobalHotKeyManager, // Removed unused HotKeyState
    hotkey::{Code, HotKey, Modifiers},
};
use std::{collections::HashMap, error::Error}; // Removed unused str::FromStr

/// Represents the mapping from a registered hotkey ID to the complete hotkey configuration.
pub type HotkeyDeviceMap = HashMap<u32, HotkeyMapping>;

/// Registers hotkeys defined in the configuration.
///
/// Takes the application configuration and initializes the global hotkey manager,
/// registering each hotkey specified in the config.
///
/// Returns a `HotkeyDeviceMap` mapping the registered hotkey IDs to their corresponding
/// device configurations, and a `Vec<HotKey>` containing the registered hotkeys for later unregistration.
/// Requires a reference to the `GlobalHotKeyManager` created in the appropriate thread.
pub fn register_hotkeys(
    manager: &GlobalHotKeyManager,
    config: &Config,
) -> Result<(HotkeyDeviceMap, Vec<HotKey>), Box<dyn Error>> {
    let mut hotkey_device_map: HotkeyDeviceMap = HashMap::new();

    println!("Registering hotkeys..."); // Debugging output

    let mut hotkeys: Vec<HotKey> = Vec::new(); // Store hotkeys for later use
    for mapping in &config.hotkeys {
        // Parse the combined keys string (e.g., "Ctrl+Alt+1")
        let hotkey = parse_hotkey_string(&mapping.keys)
            .map_err(|e| format!("Failed to parse hotkey string '{}': {}", mapping.keys, e))?;

        hotkeys.push(hotkey.clone()); // Store the hotkey for later use

        let id = hotkey.id(); // Get the unique ID generated by the HotKey struct

        println!(
            "  Registering: Keys='{}' -> Modifiers={:?}, Key={:?}, ID={}, Device='{}', Input Device='{:?}'",
            mapping.keys, hotkey.mods, hotkey.key, id, mapping.device_name, mapping.input_device_name
        ); // More detailed debug

        manager.register(hotkey)?;

        // Store the mapping from the hotkey's ID to the complete mapping configuration
        hotkey_device_map.insert(id, mapping.clone());
    }

    if hotkey_device_map.is_empty() {
        println!("Warning: No hotkeys found in the configuration to register.");
    } else {
        println!(
            "Successfully registered {} hotkeys.",
            hotkey_device_map.len()
        );
    }

    Ok((hotkey_device_map, hotkeys))
}

/// Parses a string like "Ctrl+Alt+F1" into a `HotKey`.
fn parse_hotkey_string(s: &str) -> Result<HotKey, String> {
    let parts: Vec<&str> = s
        .split('+')
        .map(str::trim)
        .filter(|p| !p.is_empty())
        .collect();
    if parts.is_empty() {
        return Err("Hotkey string cannot be empty".to_string());
    }

    let mut modifiers = Modifiers::empty();
    let mut key_part: Option<&str> = None;

    for (i, part) in parts.iter().enumerate() {
        if i == parts.len() - 1 {
            // Assume the last part is the key
            key_part = Some(part);
        } else {
            // Parse modifiers
            match part.to_lowercase().as_str() {
                "shift" => modifiers |= Modifiers::SHIFT,
                "ctrl" | "control" => modifiers |= Modifiers::CONTROL,
                "alt" | "option" => modifiers |= Modifiers::ALT,
                "win" | "super" | "meta" => modifiers |= Modifiers::META,
                _ => return Err(format!("Unknown modifier: {}", part)),
            }
        }
    }

    let key_str = key_part.ok_or("No key part found in hotkey string")?;
    let key_code = parse_key_code(key_str)?;

    Ok(HotKey::new(Some(modifiers), key_code))
}

/// Parses the key code string (e.g., "F1", "KeyA", "1") into a `Code`.
/// This is essentially the `FromStr` logic moved here.
fn parse_key_code(s: &str) -> Result<Code, String> {
    // This mapping needs to be comprehensive based on `global_hotkey::hotkey::Code` variants.
    match s.to_uppercase().as_str() {
        "A" | "KEYA" => Ok(Code::KeyA),
        "B" | "KEYB" => Ok(Code::KeyB),
        "C" | "KEYC" => Ok(Code::KeyC),
        "D" | "KEYD" => Ok(Code::KeyD),
        "E" | "KEYE" => Ok(Code::KeyE),
        "F" | "KEYF" => Ok(Code::KeyF),
        "G" | "KEYG" => Ok(Code::KeyG),
        "H" | "KEYH" => Ok(Code::KeyH),
        "I" | "KEYI" => Ok(Code::KeyI),
        "J" | "KEYJ" => Ok(Code::KeyJ),
        "K" | "KEYK" => Ok(Code::KeyK),
        "L" | "KEYL" => Ok(Code::KeyL),
        "M" | "KEYM" => Ok(Code::KeyM),
        "N" | "KEYN" => Ok(Code::KeyN),
        "O" | "KEYO" => Ok(Code::KeyO),
        "P" | "KEYP" => Ok(Code::KeyP),
        "Q" | "KEYQ" => Ok(Code::KeyQ),
        "R" | "KEYR" => Ok(Code::KeyR),
        "S" | "KEYS" => Ok(Code::KeyS),
        "T" | "KEYT" => Ok(Code::KeyT),
        "U" | "KEYU" => Ok(Code::KeyU),
        "V" | "KEYV" => Ok(Code::KeyV),
        "W" | "KEYW" => Ok(Code::KeyW),
        "X" | "KEYX" => Ok(Code::KeyX),
        "Y" | "KEYY" => Ok(Code::KeyY),
        "Z" | "KEYZ" => Ok(Code::KeyZ),
        "1" | "DIGIT1" => Ok(Code::Digit1),
        "2" | "DIGIT2" => Ok(Code::Digit2),
        "3" | "DIGIT3" => Ok(Code::Digit3),
        "4" | "DIGIT4" => Ok(Code::Digit4),
        "5" | "DIGIT5" => Ok(Code::Digit5),
        "6" | "DIGIT6" => Ok(Code::Digit6),
        "7" | "DIGIT7" => Ok(Code::Digit7),
        "8" | "DIGIT8" => Ok(Code::Digit8),
        "9" | "DIGIT9" => Ok(Code::Digit9),
        "0" | "DIGIT0" => Ok(Code::Digit0),
        "F1" => Ok(Code::F1),
        "F2" => Ok(Code::F2),
        "F3" => Ok(Code::F3),
        "F4" => Ok(Code::F4),
        "F5" => Ok(Code::F5),
        "F6" => Ok(Code::F6),
        "F7" => Ok(Code::F7),
        "F8" => Ok(Code::F8),
        "F9" => Ok(Code::F9),
        "F10" => Ok(Code::F10),
        "F11" => Ok(Code::F11),
        "F12" => Ok(Code::F12),
        "SPACE" => Ok(Code::Space),
        "ENTER" | "RETURN" => Ok(Code::Enter), // Added Return alias
        "ESCAPE" | "ESC" => Ok(Code::Escape),  // Added Esc alias
        "BACKSPACE" => Ok(Code::Backspace),
        "TAB" => Ok(Code::Tab),
        "ARROWLEFT" | "LEFT" => Ok(Code::ArrowLeft),
        "ARROWRIGHT" | "RIGHT" => Ok(Code::ArrowRight),
        "ARROWUP" | "UP" => Ok(Code::ArrowUp),
        "ARROWDOWN" | "DOWN" => Ok(Code::ArrowDown),
        // Add other common keys
        "MINUS" | "-" => Ok(Code::Minus),
        "EQUAL" | "=" => Ok(Code::Equal),
        "BRACKETLEFT" | "[" => Ok(Code::BracketLeft),
        "BRACKETRIGHT" | "]" => Ok(Code::BracketRight),
        "BACKSLASH" | "\\" => Ok(Code::Backslash),
        "SEMICOLON" | ";" => Ok(Code::Semicolon),
        "QUOTE" | "'" => Ok(Code::Quote),
        "BACKQUOTE" | "`" => Ok(Code::Backquote),
        "COMMA" | "," => Ok(Code::Comma),
        "PERIOD" | "." => Ok(Code::Period),
        "SLASH" | "/" => Ok(Code::Slash),
        "CAPSLOCK" => Ok(Code::CapsLock),
        "SCROLLLOCK" => Ok(Code::ScrollLock),
        "NUMLOCK" => Ok(Code::NumLock),
        "PRINTSCREEN" => Ok(Code::PrintScreen),
        "PAUSE" => Ok(Code::Pause),
        "INSERT" => Ok(Code::Insert),
        "HOME" => Ok(Code::Home),
        "PAGEUP" => Ok(Code::PageUp),
        "DELETE" => Ok(Code::Delete),
        "END" => Ok(Code::End),
        "PAGEDOWN" => Ok(Code::PageDown),
        "NUMPAD0" | "NUM0" => Ok(Code::Numpad0),
        "NUMPAD1" | "NUM1" => Ok(Code::Numpad1),
        "NUMPAD2" | "NUM2" => Ok(Code::Numpad2),
        "NUMPAD3" | "NUM3" => Ok(Code::Numpad3),
        "NUMPAD4" | "NUM4" => Ok(Code::Numpad4),
        "NUMPAD5" | "NUM5" => Ok(Code::Numpad5),
        "NUMPAD6" | "NUM6" => Ok(Code::Numpad6),
        "NUMPAD7" | "NUM7" => Ok(Code::Numpad7),
        "NUMPAD8" | "NUM8" => Ok(Code::Numpad8),
        "NUMPAD9" | "NUM9" => Ok(Code::Numpad9),
        "NUMPADDECIMAL" | "NUMDECIMAL" => Ok(Code::NumpadDecimal),
        "NUMPADADD" | "NUMADD" => Ok(Code::NumpadAdd),
        "NUMPADSUBTRACT" | "NUMSUBTRACT" => Ok(Code::NumpadSubtract),
        "NUMPADMULTIPLY" | "NUMMULTIPLY" => Ok(Code::NumpadMultiply),
        "NUMPADDIVIDE" | "NUMDIVIDE" => Ok(Code::NumpadDivide),
        "NUMPADENTER" | "NUMENTER" => Ok(Code::NumpadEnter),
        // ... consult global_hotkey docs for any missing codes ...
        _ => Err(format!("Unknown or unsupported key code: {}", s)),
    }
}

// Optional: Add a function to handle cleanup if needed, though the manager might handle it on drop.
// pub fn unregister_hotkeys(manager: &GlobalHotKeyManager, hotkeys: &[HotKey]) -> Result<(), Box<dyn Error>> {
//     println!("Unregistering hotkeys...");
//     for hotkey in hotkeys {
//         manager.unregister(*hotkey)?;
//     }
//     println!("Hotkeys unregistered.");
//     Ok(())
// }
